{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Reqman","text":"<p>Reqman is a postman killer. It shares the same goal, but without GUI ... the GUI is simply your favorite text editor, because requests/tests are only simple yaml files. Reqman is a command line tool, available on any platforms.</p> <p>All configurations is done via simple yaml files, editable with any text editors. Results are displayed in console and in an html output. It's scriptable, and can be used as a daemon/cron task to automate your tests.</p> <p>Info</p> <p>Here is an online converter of swagger/openapi3, OR postman collections to reqman's tests !</p> <p>Reqman shines with:</p> <ul> <li>Tests http apis / website</li> <li>Non regression tests</li> <li>Automatic tests</li> <li>Batch http process</li> <li>TDD of apis</li> </ul> <p>Reqman's history : postman is cool, but is not adapted to non-tech people, to implement \"tests\" (need JS knowledge), when things going harder. Btw, it (the free version) is a mess when you want to share your tests in a source control system. And the lack of a headless mode (#), for scripting is problematic. So there were room for reqman. With reqman you can put your complex things in reqman.conf, and let your tests be simple, and easily maintenable by non-tech people. (#: nowadays, it exists, but it's complex to setup)</p> <p>Reqman's name is a joke, a contraction of \"request\" and \"man\" ... and it can do a lot more than just POST requests ;-)</p> <p>Info</p> <p>The reqman2, is a full rewrite of reqman1, with new features as Dual Mode and RMR file.</p>"},{"location":"command/","title":"The command line","text":"<p>You can pass as many yaml's test files or folders as you want. Reqman will compute a list of tests, and order them according names. </p> <p>Tip</p> <p>It's a good practice, to prefix filenames with numbers. </p> <p>Tip</p> <p>Reqman will ignore files/folders starting with a \".\" or \"_\".</p> <p>And it will run the tests against the first <code>reqman.conf</code> found in the common path (ascending), if it exists.</p> <p>If reqman.conf contains switches, you'll be able to add switches in your command line.</p>"},{"location":"command/#reqmans-usage","title":"Reqman's usage","text":"<ul> <li><code>options</code> are internal features of reqman, and starts with 2 \"-\".</li> <li><code>switches</code> are exposed features of your <code>reqman.conf</code>, and starts with 1 \"-\". (it can start with 1 '+', to enable Dual Mode). It's the common place, to set your environment for your tests.</li> </ul> <p>Info</p> <p>NEW(since 2.2.4.0) : there is a way to declare var in environment from command line</p> <p>Example: <code>$ reqman . var:value</code></p> <p>will declare the var named 'var' valued with content 'value' in the env.</p> <pre><code>USAGE TEST   : reqman [--option] [-switch] &lt;folder|file&gt;...\nUSAGE CREATE : reqman new &lt;url&gt;\nVersion 3.0.4\nTest a http service with pre-made scenarios, whose are simple yaml files\n(More info on https://github.com/manatlan/reqman)\n\n&lt;folder|file&gt; : yml scenario or folder of yml scenario\n                (as many as you want)\n\n[option]\n        --k        : Limit standard output to failed tests (ko only)\n        --p        : Paralleliz file tests (display only ko tests)\n        --o:name   : Set a name for the html output file\n        --o        : No html output file, but full console\n        --b        : Open html output in browser if generated\n        --s        : Save RMR file (timestamped)\n        --S        : Save RMR file (reqman.rmr)\n        --r        : Replay the given RMR file in dual mode\n        --i        : Use SHEBANG params (for a single file), alone\n        --f        : Force full output in html rendering\n        --j:name   : Set a name for the junit-xml output file\n        --j        : Generate a junit-xml output file (reqman.xml)\n        --x:var    : Special mode to output an env var (as json output)\n</code></pre>"},{"location":"command/#-k-only-ko","title":"--k: only ko","text":"<p>Will output, in console, only the failed tests (DEPRECATED)</p>"},{"location":"command/#-p-paralleliz","title":"--p: paralleliz","text":"<p>Will run a \"thread\" by test's file. It's a lot speeder ;-)</p>"},{"location":"command/#-b-browser","title":"--b: browser","text":"<p>Will open <code>reqman.html</code> file in the default browser, after tests.</p>"},{"location":"command/#-o-html-output-file","title":"--o: html output file","text":"<p>If you need to set a name for the html output file, you can do it with that. (it can be useful when reqman is scripted, and you need to produce different html result) By default, the file will alwasys be named <code>reqman.html</code>.</p> <p>Examples:</p> <p><code>$ reqman . --o:mytests.html</code></p> <p>The html output file will be named 'mytests.html'</p> <p><code>$ reqman . --o</code></p> <p>It's a special case, when you don't want a html result.</p> <p>Info</p> <p>In that case : the full http exchange is outputed in the console.</p>"},{"location":"command/#-s-save-a-rmr-file","title":"--s: Save a RMR file","text":"<p>Save a RMR file for later use The filename is timestamped</p>"},{"location":"command/#-s-save-a-rmr-file_1","title":"--S: Save a RMR file","text":"<p>Save a RMR file for later use The filename will be \"reqman.rmr\"</p>"},{"location":"command/#-r-replay-a-rmr-file","title":"--r: Replay a RMR file","text":"<p>Replay a RMR file (new feature in reqman2)</p>"},{"location":"command/#-f-force-full-output-in-html","title":"--f: force full output in html","text":"<p>To minimize html'filesize. Big output is truncated. If you want to have the full output, you can pass this option.</p>"},{"location":"command/#-j-generate-junit-xml-output","title":"--j: generate junit-xml output","text":"<p>With this option, you can tell to reqman to output a \"reqman.xml\" file. Can be used with Jenkins\u2019 or Bamboo\u2019s pretty graphs. (This file is computer readable)</p>"},{"location":"command/#-jxxxx-generate-junit-xml-output","title":"--j:xxxx: generate junit-xml output","text":"<p>Same as \"--j\", but you can set a filename.</p> <p>Example:</p> <p><code>$ reqman . --j:mytests.xml</code></p>"},{"location":"command/#-xxxxx-output-an-internal-var","title":"--x:xxxx: output an internal var","text":"<p>Same as \"--j\", but you can set a filename.</p> <p>Example:</p> <p>Imagine that you have a test, which create/save a var named \"myresult\" With this option, you can output its content in stdout with <code>$ reqman . --x:myresult</code></p>"},{"location":"command/#start-a-new-project","title":"Start a new project","text":"<p>There is a special command to help you to start a new project from scratch :</p> <pre><code>$ reqman new https://www.example.com/myapi/v1/test\n</code></pre> <p>It will create, in the current folder, a (very) basic reqman.conf and a test file against this url</p> <p>And you can run test immediatly (in current folder):</p> <pre><code>$ reqman .\n</code></pre>"},{"location":"command/#shebang-mode","title":"Shebang mode","text":"<p>It's my most loved feature, over reqman1 ;-)</p> <p>It brings the power of the shebang's linux on windows platforms.</p> <p>Very useful in a text editor : just configure your editor to run the edited yaml file against reqman executable. And if you run a single file, without any parameters. Reqman will look at the shebang, and use the parameters.</p> <pre><code>#!/usr/local/bin/reqman --b -prod\n- GET: /&lt;&lt;path&gt;&gt;\n  params:\n    path: \"hello\"\n</code></pre> <p>or</p> <pre><code>#! --b -prod\n- GET: /&lt;&lt;path&gt;&gt;\n  params:\n    path: \"hello\"\n</code></pre> <p>Will run the file, with <code>prod</code> switch, and open the html output in the default browser ... (if the file is runned with others files or with options/switches ... reqman will use options/switches from commandline)</p> <p>Very handy, to avoid to go in console while coding your test, from your editor ;-)</p>"},{"location":"command/#dual-mode","title":"Dual mode","text":"<p>It let you compare the html results of two environments switches ! To enable dual mode, you will need to pass switches prefixed by '<code>-</code>' and '<code>+</code>'.</p> <p>Imagine the following reqman.conf</p> <pre><code>root: http://localhost\n\nswitches:\n  env1:\n    root: https://env1.example.com\n  env2:\n    root: https://env2.example.com\n</code></pre> <p>You can compare the dual execution tests, by using :</p> <pre><code>$ reqman . -env1 +env2\n</code></pre> <p>It will produce an html output file where you could compare, side by side, the execution of your tests on each environment, in one shot. Very handy to spot problems ;-)</p> <p>Info</p> <p>Tests are executed in parallel, to save times ;-)</p> <p>Info</p> <p>You can add as many swithes as you want. Those with \"-\" refer to the left one, those with \"+\" refer to the right one.</p> <p>Info</p> <p>If you don't mix '<code>-</code>' and '<code>+</code>' you will be in single mode only. You need to mix them to fire up dual mode. (adding just '<code>+</code>' switches (without '<code>-</code>' switches), you will be in single mode only)</p>"},{"location":"command/#rmr-file","title":"RMR file","text":"<p>A RMR file is a saved state of all requests/tests results. It's an \"image\" of a test suite results, at a given time. RMR means \"ReqMan Results\".</p> <p>It's a reqman's feature which lets you :</p> <ul> <li>save the state</li> <li>replay the tests (same context)</li> <li>compare the states</li> <li>share a test suite (one file : the rmr), without sharing the yamls/reqman.conf.</li> </ul> <p>Info</p> <p>Technically, it's the resulting reqman objects which are just zipped and saved in a file (pickle), for later use.</p>"},{"location":"command/#save-the-state","title":"Save the state","text":"<p>Just use the option <code>--s</code></p> <pre><code>$ reqman . --s\n</code></pre> <p>It will execute the tests, in a regular way ... and will save a rmr file (timestamp named)</p> <p>Tip</p> <p>At anytime, you can see the content of a RMR file, by calling <code>$ reqman &lt;yourfile&gt;.rmr</code> It will just regenerate the <code>reqman.html</code> file, with the content of the RMR.</p>"},{"location":"command/#replay-the-rmr-same-context","title":"Replay the rmr (same context)","text":"<p>Just use the option <code>--r</code> by giving the rmr filename</p> <pre><code>$ reqman --r 191215_1706.rmr\n</code></pre> <p>In that case : it replays the tests, and will save a html file in dual mode :  the previous state (left one) VS a current state (right one)</p> <p>It will replay the tests with the given switches when it was produced ! Same tests, same context ... but at a different time.</p> <p>Info</p> <p>Very useful for \"non regression tests\" (TNR)</p> <p>Warning</p> <p>When using <code>--r</code>, it's not possible to add swicthes to commandline ! The <code>--r</code> is just for replaying the same tests, to see a fresh version in Dual mode.</p>"},{"location":"command/#tests-the-rmr","title":"Tests the rmr","text":"<p>As the RMR is a file containing all executed tests. It's possible to use it, as base tests, for tests in others contexts. Just pass the rmr file to the command line, as you give yaml, and add swicthes.</p> <p>Tip</p> <p>Note that, if you don't add switches, it will just regenerate the output html. (to see the content)</p>"},{"location":"command/#in-another-context","title":"In another context","text":"<p>You can change the context, by providing switches prefixed by \"<code>-</code>\". It will replay the tests from the rmr, in the context, defined by your \"<code>-</code>\" swithes. It will ouput an html in single mode.</p>"},{"location":"command/#with-another-context-in-dual-mode","title":"With another context, in dual mode","text":"<p>You can start a dual mode tests, by providing switches prefixed by \"<code>+</code>\". It will replay the tests from the rmr, in the context, defined by your \"<code>+</code>\" swithes. It will ouput an html in dual mode : the original tests from the RMR VS the fresh ones in the new context.</p>"},{"location":"command/#share-a-test-suite","title":"Share a test suite","text":"<p>So, the rmr file can be shared with your users. They couldn't change the tests, the order, ... But the will be able to tests it without dealing with yaml, subfolders or reqman.conf.</p> <p>To see the given state (what they should have)</p> <pre><code>$ reqman state.rmr\n</code></pre> <p>To test the rmr in another context</p> <pre><code>$ reqman state.rmr -context1\n</code></pre> <p>To compare the rmr with another context(2)</p> <pre><code>$ reqman state.rmr +context2\n</code></pre> <p>To compare the rmr, in a fresh state, with another context(2)</p> <pre><code>$ reqman state.rmr -context1 +context2\n</code></pre> <p>Info</p> <p>Note, that it's the same syntax as classic calls, with yaml or subfolders in place of \"state.rmr\".</p>"},{"location":"conf/","title":"Using a reqman.conf","text":"<p>It can be very useful to share common things in a single place : the <code>reqman.conf</code> is here for that ! It's not needed: reqman can work without it. But if you need to share things between many files ; it's the place.</p> <p>Basically, it's a yaml file, which is a dictionnary of key:value.</p> <p>It is useful :</p> <ul> <li>to define some globals parameters (and root, timeout, headers, ...)</li> <li>to declare some switches for command line.</li> <li>to share some global procedures between yaml's files.</li> <li>to share some global python params/methods between yaml's files.</li> </ul>"},{"location":"conf/#define-some-globals-parameters","title":"Define some globals parameters","text":"<p>In the <code>reqman.conf</code>, you can create as many global parameters as you want, in a dict form ;-)</p> <p>Example:</p> <pre><code>myValue: 42\n\nmyList:\n  - 12\n  - \"hello\"\n</code></pre> <p>In fact you can create as many params as you want, but you should avoid to name your params with the reserved keywords : <code>root</code>, <code>timeout</code>, <code>headers</code>, <code>switches</code>, <code>BEGIN</code> &amp; <code>END</code> whose have a special function.</p>"},{"location":"conf/#root","title":"\"root\"","text":"<p>It's the root path, which is used as prefix when a request use a relative path</p> <pre><code>root: https://example.com\n</code></pre> <p>tip: this var can be overriden in a \"params\"/\"foreach\" statement.</p> <p>Info</p> <p>the <code>root</code>'s content is auto-prepended on request's path which doesn't have a scheme/protocol (http(s)://, ws(s):// ...)</p>"},{"location":"conf/#timeout","title":"\"timeout\"","text":"<p>It's the max time in milliseconds to wait the response</p> <pre><code>timeout: 100  #100ms max\n</code></pre> <p>tip: this var can be overriden in a \"params\"/\"foreach\" statement.</p>"},{"location":"conf/#headers","title":"\"headers\"","text":"<p>Global headers for all tests</p> <pre><code>headers:\n    content-type: application/json\n</code></pre>"},{"location":"conf/#declare-switches-for-command-line","title":"Declare switches for command line","text":""},{"location":"conf/#switches","title":"\"switches\"","text":"<p>Switches are a reqman's feature, to let you override default param with command line switches.</p> <p>Here is a simple reqman.conf:</p> <pre><code>root: https://example.com\n\nswitches:\n    goog: \n        root: https://google.com\n</code></pre> <p>if you run :</p> <pre><code>$ reqman test.yml\n</code></pre> <p>it will use <code>https://example.com</code> as root var.</p> <p>if you run :</p> <pre><code>$ reqman test.yml -goog\n</code></pre> <p>it will use <code>https://google.com</code> as root var.</p> <p>In fact, every things declared under the <code>goog</code> key will override things which are declared at the root of the file.</p> <p>You can combine as many switches as you want ...</p> <p>BTW, you can add a 'doc' statement, which will appear in command line usage, like this:</p> <pre><code>root: https://example.com\n\nswitches:\n    goog: \n        doc: \"to test google ;-)\"\n        root: https://google.com\n</code></pre> <p>Info</p> <p>Previous Reqman versions used <code>switchs</code> statement (a spelling error). But now, the two syntax are supported ... but prefer <code>switches</code> (it's more compliant ;-))</p>"},{"location":"conf/#declare-procedures","title":"Declare procedures","text":"<p>As you can declare a procedure in a yaml's test file, you can declare it in the reqman.conf. So every test's files can use it.</p> <p>But there are two special procedures: <code>BEGIN</code> &amp; <code>END</code></p>"},{"location":"conf/#begin-procedure","title":"\"BEGIN\" procedure","text":"<p>It's a special procedure, which can be declared in reqman.conf only, and is auto-called at the beginning of all tests. It can be useful to obtain an oauth2 token bearer, initiate some things, ...</p>"},{"location":"conf/#end-procedure","title":"\"END\" procedure","text":"<p>It's a special procedure, which can be declared in reqman.conf only, and is auto-called at the end of all tests. It can be useful to clear some things after all tests, ...</p>"},{"location":"demo/","title":"A video of a use case","text":""},{"location":"demo/#an-online-demo","title":"An online Demo","text":"<p>Here is a showcase : an online GUI to test reqman : test-reqman.glitch.me</p> <p>BUT It's limited :</p> <ul> <li>You can't use python methods in tests (security concerns)</li> <li>You can't use multiple switches in commandline (just one, for fun)</li> <li>You can't test others options of the commandline</li> </ul> <p>Warning</p> <p>Keep in mind that reqman was designed to be a commandline tool, to be runned in console, on any platforms!</p> <p>Otherwise, it can be useful too, to quickly design a test suite or to report a bug in a test suite.</p>"},{"location":"example/","title":"A classic example","text":"<p>Here is a classic config, with oauth2 flow authentification, and two mode switches.</p> <p>When reqman is executed without switches (<code>reqman test.yml</code>):</p> <ul> <li>It will target the server on localhost.</li> <li>It will use a default access_token, for development</li> </ul> <p>When reqman is executed with a switch 'prod' (<code>reqman test.yml -prod</code>):</p> <ul> <li>It will target the server on example.com (root overriden)</li> <li>It will try to obtain a access_token on authorization server (via BEGIN procedure)</li> </ul>"},{"location":"example/#a-reqmanconf","title":"A reqman.conf","text":"<pre><code>root:                 http://localhost:8080\n\ntoken:                # jwt token for local dev\n  token_type:         Bearer\n  access_token:       eyJhbGciOiJIUzI1NiIsInR6cCI6IkpXVCJ9.eyJzdWIiOiIxMzUwNjg4MjciLCJjZGV0YWIiOiIxNjI3NSIsImFwcGlkIjoicG9zdGVfbG9jYWwifQ.XMPNGpB5TUbmm08h2s79KYol32MQaRT_CvhAoTBBBnI\n\nheaders:\n  Content-Type:       application/json; charset=utf-8\n  x-hello:            it's me\n  Authorization:      &lt;&lt;token.token_type&gt;&gt; &lt;&lt;token.access_token&gt;&gt;\n\nswitches:\n  prod:\n    doc:                Test in production\n    root:               https://example.com\n\n    BEGIN:\n      POST:             https://authorization.server.example.com/oauth/token\n      headers:\n        Content-Type:   application/x-www-form-urlencoded\n      body:             grant_type=client_credentials&amp;client_id=dbfa1d28-c815-4b61-a435-0b2b761d30ab&amp;client_secret=cbe46cde-affb-4324-8f26-f69ace80f1ce\n      tests:\n        - status:       200\n      save:             token\n</code></pre>"},{"location":"example/#and-a-yml-test-file","title":"And a yml test file","text":"<pre><code>- GET: /api/pets/v1/list\n  tests:\n    - status: 200\n  save:\n    pets: &lt;&lt;json.items&gt;&gt;\n\n- GET: /api/pets/v1/info/&lt;&lt;id&gt;&gt;\n  params:\n    id: &lt;&lt;json.items.0.id&gt;&gt;\n</code></pre>"},{"location":"from_postman/","title":"If you came from postman","text":"<p>Don't be afraid ... There is no GUI. The GUI is your file editor (it can be vscode, eclipse, notepad++, ...) as long as it support the yaml syntax. And you can run them directly from your text editor, by linking the test file to reqman executable. It's more natural to copy/paste/duplicate your tests easily.</p> <p>reqman is heavily based on postman concepts :</p> <ul> <li>the collection : it can be a yaml file, or a subfolder with reqman's yaml tests. It's up to you to run it with your desired tests. You can organize them as you want.</li> <li>the environment : it's basically the things in your <code>reqman.conf</code>. It's the place the common things to all tests : the globals vars, the init's process, the swicthes to change context, ...</li> </ul> <p>A base structure folder could be like this :</p> <pre><code>    \u251c\u2500\u2500 10-tests-authent              \\\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 10-login.yml              |\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 20-signout.yml            |\n    \u251c\u2500\u2500 20-tests-basket               \u251c- the collection\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 10-add-product.yml        |\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 20-show-basket.yml        |\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 30-checkout.yml           /\n    reqman.conf                       &lt;- the environment\n</code></pre> <p>Tip</p> <p>it's a good practice to suffix files with number, to easily reach them in console with auto-completion in the commandline.</p> <p>If you want to test the authent/signout :</p> <pre><code>$ reqman 10-tests-authent/20-signout.yml\n</code></pre> <p>(you type reqman, space, 1 and fire up the autocompletion with tab, and 2 and autocompletion )</p> <p>If you want to test all your baskets tests :</p> <pre><code>$ reqman 20-tests-basket\n</code></pre> <p>If you have defined switches in your <code>reqman.conf</code>, and want to test your baskets tests in <code>prod</code> environment</p> <pre><code>$ reqman 20-tests-basket -prod\n</code></pre> <p>if you want to tests all in <code>prod</code></p> <pre><code>$ reqman . -prod\n</code></pre>"},{"location":"from_postman/#about-requests","title":"About requests","text":"<p>In postman, it's easy to upload a file in your request, or authentificate your request on AWS, etc ... using the GUI and availables features in postman.</p> <p>In reqman there is no special/dedicated features for theses simples things. BUT there is more : a way to embed python in yaml's tests. So, basically, you can do all that is available in python, in reqman's tests. It gives the ability to do a lot of things, but you will need python knowledgment.</p> <p>So uploading a file, or compute a signature can be done in 2/3 lines of python code in the yaml.</p> <p>But don't be afraid, you don't need to use/known python in your tests in 99% cases. It's just for power users, but it adds the ability to do a lot of complex things.</p>"},{"location":"from_postman/#about-tests","title":"About tests","text":"<p>In postman, you can control the response object with javascript (to test the returned status code is 200, or the content-type is json, etc ...). In reqman, this kind of tests are simple yaml statements, that you describe in your yaml/requests flow. It's really easy to write tests, and allow non-tech people to write them. (really important to separate the concerns)</p> <p>The reqman's reporting (in console, or the more detailled exchange in the html output) will sort theses tests with \"OK\" or \"KO\" statement, depending of the results. and display you a summary of the state. If you match, for example: 277/277, you can consider 100% OK. If you match 250/277, there are 27 KO results.</p> <p>BTW, the command line return a code :</p> <ul> <li>0  : which means 0 KO tests. Everything is OK, 100%</li> <li>x  : the number of failed (KO) tests</li> <li>-1 : there was at least one request that couldn't be executed (timeout, unreachable, error in yaml, ...)</li> </ul> <p>So it's easily scriptable, for example : a reqman cron task can easily send you a SMS, or a mail, to alert you if it fails.</p>"},{"location":"from_postman/#conversion","title":"Conversion","text":"<p>If you want to test : you can convert your exported postman collection.</p> <p>The tool is not magic :</p> <ul> <li>You will loose your structured sub-collections (only the structure, not the requests). Everything is outputed in one flow. It's up to you to copy/paste in your future reqman tests collection.</li> <li>You will need to adapt, according your environment (to resolve global/envs vars)</li> <li>The converter can't reproduce the javascript tests/scripts ... you will need to add them manually.</li> </ul> <p>But it's good way to see how it will work for you, by copying/pasting requests in your yaml's tests files.</p> <p>BTW, in normal case, this tool will help you to create your first tests using a swagger/openapi specifications.</p> <p>Info</p> <p>this tool is only available online (because it's not finished). But will release it on github, when done.</p>"},{"location":"install/","title":"reqman","text":""},{"location":"install/#tldr","title":"TL;DR","text":"<p><code>reqman</code> is a command line tool to test your http requests. It uses <code>.yml</code> files, which are simple yaml files, to define your requests and tests.</p>"},{"location":"install/#installation-using-pip","title":"Installation using pip","text":"<p>If you got python3 on your host, you can install it thru pip/pip3, like that:</p> <pre><code>$ pip3 install reqman\n</code></pre>"},{"location":"install/#installation-using-uv","title":"Installation using uv","text":"<p>If you got uv on your host, you can run it like that:</p> <pre><code>$ uvx reqman\n</code></pre> <p>Or install it as an uv's tool</p> <pre><code>$ uv tool install reqman\n</code></pre>"},{"location":"install/#if-you-are-on-windows11","title":"If you are on windows11","text":"<p>You can download an executable on releases page</p>"},{"location":"python/","title":"Python powered","text":"<p>Using \"params\" statement, it's possible to embbed python3 scripts, to make your tests more powerful.</p> <p>Can be really useful to:</p> <ul> <li>transform data (gzip, base64, encrypt, ...)</li> <li>save/read content from filesystem</li> <li>compute complex data</li> <li>...</li> </ul> <p>Info</p> <p>You can include all python libs available in reqman, but for others libs you should have python3 on the host with yours libs.</p>"},{"location":"python/#with-param-value","title":"With param value","text":"<pre><code>- POST: /post\n  body: &lt;&lt;content&gt;&gt;\n  params:\n    content: |\n        with open(\"image.jpg\",\"rb\") as fid:\n            return fid.read()\n</code></pre>"},{"location":"python/#with-method-over-a-param-value","title":"With method over a param value","text":"<p>it's like a param, but 'x' is the input parameter (ENV dict is also available)</p> <pre><code>- POST: /post\n  body: &lt;&lt;content|gzip&gt;&gt;\n  params:\n    content: \"hello world\"\n    gzip: |\n        import zlib\n        return zlib.compress( bytes(x,\"utf8\") )\n</code></pre> <p>And you can chain methods like this</p> <pre><code>- POST: /post\n  body: &lt;&lt;content|gzip|b64&gt;&gt;\n  params:\n    content: \"hello world\"\n    gzip: |\n        import zlib\n        return zlib.compress( bytes(x,\"utf8\") )\n    b64: |\n        import base64\n        return str( base64.b64encode( bytes(x,\"utf8\") ), \"utf8\" )\n</code></pre> <p>Example of using a python method to save content during tests:</p> <pre><code>- get: /image.jpeg\n  params:\n    mysave: |\n        with open(\"myfile.jpg\",\"wb+\") as fid:\n          fid.write( x )\n        return True\n  save:\n    isSaved: &lt;&lt;content|mysave&gt;&gt;\n</code></pre> <p>Warning</p> <p>You will need version &gt;= 2.2.3.0 (previous was bugged ;-( ) </p>"},{"location":"python/#improve-tests","title":"Improve tests","text":"<p>You can improve the way you test yours api, by adding python in your tests. Here is an example :</p> <pre><code>- GET: /my_api\n  params:\n    my_own_test: |\n        import re\n        return True if re.search( \"^2\", str(x) ) else False\n  tests:\n    - status|my_own_test: true\n</code></pre> <p>Tip</p> <p>A better place for theses methods : declare them in the reqman.conf !</p>"},{"location":"simple_use/","title":"Simplest use","text":"<p>Create a yml file (ex: <code>test.yml</code>)</p> <pre><code>- GET: https://github.com/manatlan/reqman\n  tests:\n    - status: 200\n</code></pre> <p>And run it with reqman, in console</p> <pre><code>$ reqman test.yml\n</code></pre> <p>The console should print:</p> <p></p> <p>What's happening ?</p> <ul> <li>Reqman has requested the url</li> <li>It has tested that HTTP status == 200</li> <li>It summarizes the tests: 1/1 ... one test OK over one test (Displayed in green)</li> <li>it has generated a <code>reqman.html</code> file which contains more details about the http exchange,</li> <li>And it returned a RC code == 0 (no test errors, else will be the number of failed tests, or -1 if error)</li> </ul>"},{"location":"yml_syntax/","title":"Test's Grammar","text":""},{"location":"yml_syntax/#reqman-language-syntax","title":"Reqman language Syntax","text":"<p>A reqman's file tests, is a YAML file, endings with \".yml\" or \".rml\" (ReqMan Language).</p> <p>Its content is a list of statements. There are 4 types of statements :</p> <ul> <li>An http request</li> <li>A Procedure's declaration</li> <li>A call procedure</li> <li>A break statement</li> </ul> <p>reqman brings its own substitution mechanism. In many places (value side), you can create vars (<code>{{a_var}}</code> or <code>&lt;&lt;a_var&gt;&gt;</code>),  which will be substituted at runtime using local params, global params or saved ones</p> <p>(since 3.2.0 version : you can use your environments vars (dotenv compliant) too !)</p>"},{"location":"yml_syntax/#an-http-request","title":"An HTTP Request","text":"<p>This kind of statement, should contain ONE HTTP VERB, in uppercase (Known HTTP verbs : \"GET\", \"POST\", \"DELETE\", \"PUT\", \"HEAD\", \"OPTIONS\", \"TRACE\", \"PATCH\", \"CONNECT\")</p> <pre><code>- GET: /hello\n- OPTIONS: /hello\n- HEAD: /hello\n</code></pre> <p>And it's generally completed with additionnal keywords</p>"},{"location":"yml_syntax/#a-procedures-declaration","title":"A Procedure's declaration","text":"<p>This statement declare a procedure which can be only called by a \"call statement\".</p> <p>Here is the declaration of a procedure <code>MyProcedure</code>:</p> <pre><code>- MyProcedure:\n    - GET: /hello1\n    - GET: /hello2\n</code></pre> <p>The content of the procedure is a list which can contains the 4 types of statements.</p> <p>Note : Without a call statement : this file does nothing ...</p>"},{"location":"yml_syntax/#a-call-procedure","title":"A call procedure","text":"<p>This statement let you call a procedure.</p> <pre><code>- call: MyProcedure\n</code></pre> <p>or</p> <pre><code>- call: \n    - MyProcedure1\n    - MyProcedure2\n</code></pre> <p>And it's generally completed with additionnal keywords</p>"},{"location":"yml_syntax/#a-break-statement","title":"A 'break' statement","text":"<p>This statement is only useful, when you are working on a test file, it lets you break the process. So you can edit your statements step by step.</p> <pre><code>- GET: /hello1\n- break\n- GET: /hello2\n- GET: /hello3\n</code></pre> <p>In this case ^^; only the first request is called ... The others are simply ignored.</p>"},{"location":"yml_syntax/#additionnal-keywords","title":"Additionnal keywords","text":"<p>Theses keywords can be added on request or call statements, to complete the statement.</p>"},{"location":"yml_syntax/#body","title":"\"body\"","text":"<p>Let you add a 'body' in your POST/PUT/... statements ;-)</p> <pre><code>- POST: /hello\n  body: \"I'm the body\"\n</code></pre> <pre><code>- POST: /hello\n  body: {\"key\":12, \"value\":\"hello\"}\n</code></pre> <pre><code>- POST: /hello\n  body:\n    key: 12\n    value: \"hello\"\n</code></pre> <p>Body described in yaml syntax, will automatically converted in json. The latest 2 examples are the same.</p>"},{"location":"yml_syntax/#headers","title":"\"headers\"","text":"<p>Let you add input's 'headers' in yours statements. </p> <pre><code>- POST: /hello\n  body: \"I'm the body\"\n  headers:\n    content-type: text/plain\n    x-hello: it's me\n</code></pre> <p>If there are global or inherited headers, you can override them, by setting them to <code>null</code>, like that:</p> <pre><code>- myproc:\n    - POST: /hello\n      body: \"I'm the body\"\n      headers:\n        content-type:       # leave empty, will not send the content-type from the caller\n        x-hello: it's me\n\n- call: myproc\n  headers:\n     content-type: application/json\n</code></pre> <p>Header's keys are case insensitive.</p>"},{"location":"yml_syntax/#tests","title":"\"tests\"","text":"<p>Let you add 'tests' in yours statements. </p> <p>reqman provides you special syntax to let you write easily tests on complex content:</p> <ul> <li>basic tests: tests around http response (status, headers, content)</li> <li>json tests: tests around http response as a json object</li> <li>xml tests: tests around http response as a xml object</li> </ul> <p>Obviously, you can mix all this kind of tests ^^</p>"},{"location":"yml_syntax/#basic-tests","title":"basic tests","text":"<p>Basic tests are:</p> <ul> <li>test a http response status, with keyword <code>status</code></li> <li>test a http response header, with the desired headers</li> <li>test the http response content, with keyword <code>content</code></li> </ul> <pre><code>- GET: /returnJson  # return {\"result\":{\"content\":\"ok\",\"value\":3.3, \"list\":[42,43]}}\n  tests:\n    - status: 200\n    - content-type: application/json    # test a response header\n    - content:  \"result\"                # ensure that the global response contains text \"result\"\n    - content:  \"list\"                  # ensure that the global response contains text \"list\"\n</code></pre> <p>Here, there are 4 tests.</p> <p>If you want to tests multiple values, you can add them in a yaml's list, like this :</p> <pre><code>- GET: /returnJson\n  tests:\n    - status: \n          - 200\n          - 304\n</code></pre> <p>This test will be \"OK\", if returned status is 200 or 304.</p> <p>or simpler/shorter :</p> <pre><code>- GET: /returnJson\n  tests:\n    - status: [200, 304]\n</code></pre> <p>as json is a subset of yaml ;-)</p>"},{"location":"yml_syntax/#json-tests","title":"json tests","text":"<p><code>json</code> is a special keyword, which will be populated with the http response content. Only useful, when http response is json content. (if it's not the case, all tests are <code>null</code>)</p> <p>You can navigate in the json object model, with a simple dot notation, like this:</p> <pre><code>- GET: /returnJson  # return {\"result\":{\"content\":\"ok\",\"value\":3.3, \"list\":[42,43]}}\n  tests:\n    - status: 200                       # a basic test\n    - json.result.content: \"ok\"\n    - json.result.content: &lt;&lt;myValue&gt;&gt;  # ensure that the content is equal to myValue param\n    - json.result.content: . != \"ko\"\n    - json.result.content.size: 2       # test size of the string\n    - json.result.size: 2               # test size of the dict\n    - json.result.value: . &gt; 3\n    - json.result.value: . &lt;= 4\n    - json.result.list.size: 2          # ensure the list contains 2 values\n    - json.result.list.0: 42            # refer to the first item in the list\n    - json.result.list.1: 43            # refer to the second item in the list\n    - json.result.list.-1: 43           # refer to the last item in the list\n</code></pre> <p>Info</p> <p>the <code>.size</code> is a special key, to compute the size of the object</p>"},{"location":"yml_syntax/#xml-tests","title":"xml tests","text":"<p>Since reqman&gt;=2.3.0, xml/xpath is supported too (yet!).</p> <p><code>xml</code> is a special keyword, which will be populated with the http response content. Only useful, when http response is (valid) xml content. (if it's not the case, all tests are <code>null</code>)</p> <pre><code>- GET: https://manatlan.com/sitemap.xml\n  tests:\n    - status: 200                              # a basic test\n    - xml.//url/loc.0: https://manatlan.com/    # ensure that the first *url/loc* is the good url\n    - xml.//url.size: . &gt; 10                   # ensure that there are more than 10 urls.\n</code></pre> <p>Info</p> <ul> <li>Syntax could be <code>xml.xpath[.size]</code>, where <code>xpath</code> is a valid xpath expression    (ns clark notation not accepted).</li> <li>The xpath expression always returns a list : so you can apply the <code>.size</code>, to compute the size of the list.   Or index an element, with the dot notation (ex: \"xml.//url/loc.0\" -&gt; the first one)</li> </ul> <p>Important</p> <p>Currently, you can't use the char \".\" in the xpath expressions ... will be fixed in next releases !</p>"},{"location":"yml_syntax/#doc","title":"\"doc\"","text":"<p>It's optionnal. It let you describe your test ... This doc will be in the html reqman's output.</p> <pre><code>- GET: /test \n  doc: \"Just a test on &lt;&lt;root&gt;&gt; !\"\n</code></pre> <p>Yes, you can use var substitutions in <code>doc</code> !</p>"},{"location":"yml_syntax/#params","title":"\"params\"","text":"<p>It let you set local parameters in your statement, in a dict form.</p> <pre><code>- GET: /&lt;&lt;path&gt;&gt;\n  params:\n    path: \"hello\"\n</code></pre> <p><code>&lt;&lt;path&gt;&gt;</code> is substituted by the value of the param <code>path</code>.</p>"},{"location":"yml_syntax/#save","title":"\"save\"","text":"<p>It lets you save parameters for later use. Theses parameters are only available in the current yaml tests. Only thoses saved in the <code>BEGIN</code> procedure will be shared with all test files.</p>"},{"location":"yml_syntax/#save-all-the-response","title":"Save all the response","text":"<p>It's the way to create parameters based on results. The created param will be available in the current file test, for the following requests.</p> <p>Info</p> <p>Thoses created in a global's procedure (in reqman.conf), will be available in all tests files.</p> <pre><code>- GET: /returnJson  # return {\"result\":{\"content\":\"ok\",\"value\":3.3}}\n  save: allJson\n</code></pre> <p>Now, you can use 'allJson' in following statements</p>"},{"location":"yml_syntax/#save-a-partial-response","title":"Save a partial response","text":"<pre><code>- GET: /returnJson  # return {\"result\":{\"content\":\"ok\",\"value\":3.3}}\n  save: \n    mycontent: &lt;&lt;json.result.content&gt;&gt;\n</code></pre> <p>Now, you can use 'mycontent' in following statements</p> <p>Tip</p> <ul> <li>While saving partial response, you can applying python transformations on saved content.</li> </ul> <p>Here, it's a <code>json</code> partial content which is saved, but it could be a <code>xml</code> partial content, like this :</p> <pre><code>- GET: /returnXml\n  save: \n    mycontent: &lt;&lt;xml.//*:myNode[first()]&gt;&gt;\n</code></pre>"},{"location":"yml_syntax/#foreach","title":"\"foreach\"","text":"<p>It let you repeat your statement, with a list of dict.</p> <pre><code>- GET: /test/&lt;&lt;value&gt;&gt;\n  foreach:\n    - value: 1\n    - value: 2\n    - value: 3\n</code></pre> <p>Will make 3 requests. BTW, it's the same thing as :</p> <pre><code>- GET: /test/1\n- GET: /test/2\n- GET: /test/3\n</code></pre> <p>Info</p> <p>You can use only one <code>foreach</code> per statement. But if you need nested <code>foreach</code> you can do it using nested call statements.</p>"}]}